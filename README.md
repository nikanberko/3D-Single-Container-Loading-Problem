# 3D Single Container Loading Problem - optimized binary tree based solution
## Summary
An aproximative solution to the 3D Single Container Loading Problem via a recursive JAVA program which fits different sized boxes in a single container. 
Dimensions of the boxes and the container are given as inputs. The algorithm uses a binary tree to find a subspace in which a certain box fits. 
Since every placed box in a height bounded 2D plane splits the plane in two subareas (area to the right of the box and the area to the bottom),
the algorithm searches these subareas to find a space in which a box can fit. One or more of these "2D" layers are generated by the algorithm and "stacked" on top of
each other to form a 3D container. 

**Essentially, the algorithm aproximatively solves a 2D single bin packing problem (but height bounded) multiple times and stacks the solutions on top of each other.**

## Current state of the algorithm
The algorithm works nicely but the rotational optimization is not yet fully implemented due to a currently unsolved bug.
To try and fit all box types it is enough to take the list of boxes to be fitted and sort them in a way that all box types are at the beggining of the list
and the other boxes are sorted width-wise. There is also some code un-spaghettification to be done in the future for better code readability.

# Workings of classes and interfaces 
Further down, all the inner workings of all classes and interfaces used in the solution are explained.
## The Box class
The box class represents the basis of this solution.
The class stores essential box data such as:
box width, box depth, box height, it's origin coordinates in a 2D layer plane and the box id.
Other data regarding the BST-based algorithm like the information is a certain box the root node of the tree (isRoot field), its left and right nodes (right and down field),
and the information is the box a free space or a concrete box (isFreeSpaceBox field).

The Box class also overrides the toString() method for easier output and defines the getPlacementCoordinateDetails() method
to get the 2D layer placement coordinates in a string form.

The Box class also lists different accessor methods for the above-mentioned fields.

```
package hr.Base58;

public class Box {

    private final double depth;
    private final double width;
    private final double height;

    //defines the origin coordinates of a box
    private final double originX;
    private final double originZ;

    //denotes the root box of the box tree
    private boolean isRoot = false;

    private final String id;

    //by default the box is a "freeSpaceBox" which denotes a free space that can be occupied by a non-freeSpaceBox
    private boolean freeSpaceBox = true;

    //free space boxes to the right and down in a 2d plane
    private Box right = null;
    private Box down = null;

    //defines the box placed in the freeSpaceBox space
    private Box placedBox = null;


    public Box(String id, double originX, double originZ, double width, double depth, double height) {

        this.id=id;
        this.originX=originX;
        this.originZ=originZ;
        this.depth=depth;
        this.width=width;
        this.height=height;

    }


    @Override
    public String toString() {
        return  id + " details:" +
                "  width=" + width +
                ", height=" + height +
                "  depth=" + depth;
    }


    public String getPlacementCoordinateDetails(){
        return " box placed at " + "("+placedBox.originX +", "+ placedBox.originZ + ")"
                + " in current layer" + ',' ;
    }

    //accessors and setters
    public boolean isRoot() {

        return isRoot;

    }

    public void setAsRoot() {

        isRoot = true;

    }

    public String getId() {

        return id;

    }

    public double getOriginX() {

        return originX;

    }

    public double getOriginZ() {

        return originZ;

    }

    public double getDepth() {

        return depth;

    }

    public double getWidth() {

        return width;

    }

    public double getHeight() {

        return height;

    }

    public boolean isFreeSpaceBox() {

        return freeSpaceBox;

    }

    public void setAsUsedSpaceBox(){

        freeSpaceBox=false;

    }

    public Box getRight() {

        return right;

    }

    public void setRight(Box right) {

        this.right = right;

    }

    public Box getDown() {

        return down;

    }

    public void setDown(Box down) {

        this.down = down;

    }

    public Box getPlacedBox() {

        return placedBox;

    }

    public void placeBox(Box box) {

        this.placedBox = box;

    }

}


```

## The BoxRotationManager class 
**Not used in current version*

Since the algorithm allows for box rotation to get a better fitting result, the BoxRotationManager class is added to find the best fitting rotation given the subspace dimensions.
This class handles the rotation by defining four methods: canFit(), getRotations(), getSubSpaceFitabilityIndex() and getOptimalRotation().

**The canFit()** method simply checks if a box can fit in a subspace (think of it as a smaller container) in any rotation by comparing the sizes of the container and box dimensions.

**The getRotations()** method returns a list of the 6 basic rotations of a given box (box objects with permuted dimensions).
Basic rotations are defined as rotations resulting from 90° shifts at a time. We will use this list to find an optimal rotation for a certain subspace.

**The getSubSpaceFitabilityIndex()** method is a simple method which returns the percentage of the 2D layer subspace a box occupies.
This percentage is calculated as box.getWidth()* box.getDepth()/(spaceWidth*spaceDepth).

Since we want to define the subSpaceFitabilityIndex as a higher-is-better term, we substract it from 1, so we get the next expression:

__1 - box.getWidth()* box.getDepth()/(spaceWidth*spaceDepth)__

**The getOptimalRotation()** method is an optimization method which will return one of six rotations of a box that fits best in a given subspace.
This is done by finding the box rotation which fits in the subspace and also occupies the smallest area of the subspace.
By doing this we leave more space in the 2D layer plane unoccupied.

```
package hr.Base58;

import java.util.ArrayList;
import java.util.List;

public  class  BoxRotationManager {


    //if any dimensions of a box cannot fit in (spaceWidth,spaceDepth, maxHeight) defined space return false
    public static boolean canFit(Box box, double spaceWidth, double spaceDepth, double maxHeight){

        return !(box.getWidth()>spaceWidth || box.getWidth()> maxHeight || box.getWidth()>spaceDepth
                || box.getHeight()>spaceWidth || box.getHeight()> maxHeight || box.getHeight()>spaceDepth
                  || box.getDepth()>spaceWidth || box.getDepth()> maxHeight|| box.getDepth()>spaceDepth);

    }

    //The subSpaceFitabilityIndex is defined as the percentage of the subspace area a box occupies.
    //Since we want to define the subSpaceFitabilityIndex as a higher-is-better term, we substract it from 1.
    public static double getSubSpaceFitabilityIndex(Box box, double spaceWidth, double spaceDepth){

        return 1-(box.getWidth()* box.getDepth()/(spaceWidth*spaceDepth));

    }

    public static Box getOptimalRotation(Box box, double spaceWidth, double spaceDepth, double maxHeight ){

        List<Box> boxRotations = getRotations(box);

        List<Box> fittableRotations = new ArrayList<>(0);

        for (Box boxRotation:boxRotations) {
                //Add only boxes which can fit in the subspace
                if(canFit(boxRotation, spaceWidth, spaceDepth, maxHeight)){

                    fittableRotations.add(boxRotation);

                }

        }

        Box optimalBoxRotation=box;
        double optimalFitabilityIndex=0;
        double currentFitabilityIndex;

        //Finds the best fitting box for a subspace (see getSubSpaceFitability method).
        for (Box fittableRotation: fittableRotations) {

            currentFitabilityIndex=getSubSpaceFitabilityIndex(fittableRotation, spaceWidth, spaceDepth);

            if(currentFitabilityIndex>=optimalFitabilityIndex){

                optimalFitabilityIndex=currentFitabilityIndex;
                optimalBoxRotation=fittableRotation;

            }
        }

    return optimalBoxRotation;

    }

    //Returns all possible basic rotations of a box
    public static List<Box> getRotations(Box box){

            List<Box> boxRotations = new ArrayList<>();

            //Since every box has 6 basic rotations (rotations resulting from 90° shifts at a time), we add every rotation to the list
            //by permuting the dimensions
            boxRotations.add(box);
            boxRotations.add(new Box( box.getId(), box.getOriginX(), box.getOriginZ(),box.getWidth(), box.getDepth(), box.getHeight() ));
            boxRotations.add(new Box(box.getId(),box.getOriginX(), box.getOriginZ(), box.getHeight(), box.getWidth(), box.getDepth() ));
            boxRotations.add(new Box(box.getId(), box.getOriginX(), box.getOriginZ(),box.getHeight(),box.getDepth(), box.getWidth() ));
            boxRotations.add(new Box(box.getId(),box.getOriginX(), box.getOriginZ(), box.getDepth(),box.getWidth(), box.getHeight() ));
            boxRotations.add(new Box(box.getId(),box.getOriginX(), box.getOriginZ(), box.getDepth(),box.getHeight(), box.getWidth() ));


        return boxRotations;
    }
}

```


## The BoxLayerFitter class
The BoxLayerFitter class essentialy defines methods for a single-bin 2D bin packing problem solution with a height boundary.
Essentially this class interprets a Box object as either a free space (a container or subcontainer) or a concrete box (a placed box which occupies space).
Since the algorithm is based on a binary tree, the class first places the container (essentially a big box in which other boxes will be fitted) as the box-tree root.
The container is set as root by passing the container width, depth and height as parameters to the class constructor. The maxHeight will be set as the height of the first box placed in the layer in the future.

###### The BoxLayerFitter class defines three main method for fitting boxes in a 2D layer with a height boundary.

**The fit()** method is the exact method which fits the boxes, so let's take a closer look.

```
package hr.Base58;
import java.util.List;

public class BoxLayerFitter implements IBoxFitter {

        private final Box root;
        private final double maxHeight;

        public BoxLayerFitter(double width, double depth, double maxHeight) {

            this.maxHeight=maxHeight;

            root = new Box("root",0, 0, width, depth, 0);

        }


        public void fit(List<Box> boxes) {

            Box freeSpaceBox;
            Box boxToPlace;
            Box optimalBox;

            for (Box aBox : boxes) {

                boxToPlace = aBox;

                //optimalBox = BoxRotationManager.getOptimalRotation(this.root, boxToPlace.getWidth(), boxToPlace.getDepth(), maxHeight);
                
                freeSpaceBox = this.findSpace(this.root, boxToPlace.getWidth(), boxToPlace.getDepth());

                if (freeSpaceBox != null) {

                    boxToPlace.placeBox(this.placeAndSplitSearch(freeSpaceBox, boxToPlace.getWidth(), boxToPlace.getDepth()));

                    if (freeSpaceBox.isRoot()){

                        boxToPlace.getPlacedBox().setAsRoot();

                    }

                }
            }
        }


        public Box findSpace(Box root, double width, double depth) {

            if (!root.isFreeSpaceBox()) {

                Box right = findSpace(root.getRight(), width, depth);

                if(right!=null){

                    return right;

                }

                else{

                    return findSpace(root.getDown(), width, depth);

                }

            }
            else if ((depth <= root.getDepth()) && (width <= root.getWidth()) && root.getHeight() < maxHeight){

                return root;

            }


            else{

                return null;

            }

        }

        public Box placeAndSplitSearch(Box box, double width, double depth) {

            box.setAsUsedSpaceBox();

            box.setDown(new Box(box.getId(),box.getOriginX(), box.getOriginZ() + depth, box.getWidth(),
                    box.getDepth() - depth, box.getHeight()));

            box.setRight(new Box(box.getId(), box.getOriginX() + width, box.getOriginZ(),
                    box.getWidth() - width, depth, box.getHeight()));

            return box;
        }

}

```
        
Given a list of boxes to fit, this method iterates through the boxes and tries to fit them in a free space.
The method first tries to find a space in which a box would fit by passing the root (firstly the container) and the dimensions of the box to the **findsSpace()** method.
This method first tries to fit the box in root. If the box can't fit in the current root it recursively searches the spaces right and down of the root to find adequate space.

If the root is already used, the method **placeAndSplitSearch()** creates new free space nodes by defining the
origin points of the right and bottom space and sets the previous subspace as used.

The workings of the methods are also bounded by a maxHeight value. This value is the height of the first placed box given by the BoxLayerStacker
class which will be discussed further down.


## The BoxLayerStacker class
This class is used to stack a certain number of height-bound layers generated by the BoxLayerFitter fit() method to form a 3D container.

This is done by continuously creating new layers in the **stackLayers()** method and filling them with boxes until we use up 
all the boxes or reach the maximum container height. By removing every box placed in a layer, it is ensured that height boundary of the next layer will continuously be updated
to the height of the box that is left in the list of boxes to be placed.

To ensure the container height is never exceeded, the program sums up all the heights of the boxes first fit in
a certain layer (the height of the first box in a container defines the height boundary of a layer) and we stop the algorithm from creating new
layers when the sum reaches the container height.

Finally, the stackLayers() method returns a list of lists of boxes. Every sublist of this nested list represents a layer and every sublist
element represents a box in that layer.

The **getNumberOfPlacedBoxes()** method returns the size of placed boxes (essentially the size of the list).

```
package hr.Base58;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class BoxLayerStacker {


    private final List<List<Box>> layers;
    private final List<Box> boxes;
    private final List<Box> placedBoxes;


    public BoxLayerStacker(List<Box> boxes){

        this.boxes=boxes;
        layers=new ArrayList<>(0);
        placedBoxes= new ArrayList<>(0);

    }


    public List<List<Box>> stackLayers(Container container){

        //defines the maximum height of the current layer in context.
        double maxLayerHeight = container.getHeight();

        int boxHeightSum=0;
        int layerIndex=0;

        //Generate a new "2D" layer (plane with height boundary) every time a layer is filled.
        //The program stacks the "2D" layers on top of each other to form a 3D object, essentially, a filled container.
        while (!boxes.isEmpty()) {

            BoxLayerFitter boxLayerFitter = new BoxLayerFitter(container.getWidth(), container.getDepth(), boxes.get(0).getHeight());

            boxHeightSum+=boxes.get(0).getHeight();

            if(boxHeightSum > maxLayerHeight ) break;

            //Adds each layer (a list of placed boxes) to layer list.
            layers.add(new ArrayList<>());

            boxLayerFitter.fit(boxes);

            ListIterator<Box> boxIterator = boxes.listIterator();


            while (boxIterator.hasNext()) {

                Box box = boxIterator.next();

                if (box.getPlacedBox() != null) {

                    placedBoxes.add((box));

                    //Adds placed boxes to
                    layers.get(layerIndex).add(box);

                    //Remove box from list when placed in a freeSpaceBox space.
                    boxIterator.remove();
                }
            }

            layerIndex++;

        }

        return layers;

    }


    public int getNumberOfPlacedBoxes() {
        return placedBoxes.size();
    }
}

```

## The IBoxFitter interface
This is a simple interface that the BoxLayerFitter class implements.
It only contains one method - void fit(List<Box> boxes) and is used to simplify changing the box fitting class in the future.

```
package hr.Base58;

import java.util.List;

public interface IBoxFitter {

     void fit(List<Box> boxes);

}

```
## The IBoxGenerator interface
This is also a simple interface which declares only one method - List<Box> getBoxes();
This interface is implemented by the RandomBoxGenerator, SameSizedBoxGenerator and UserInputBoxGenerator classes 
in order to allow for dynamic swapping of box generation methods.

```
package hr.Base58;

import java.util.List;

public interface IBoxGenerator {

    List<Box> getBoxes();

}

```

## The RandomBoxGenerator class
The RandomBoxGenerator class defines the random generation of a certain number of boxes bounded by lower and upper dimension boundaries.
Using a dependency injected random generator, the getBoxes method gets the user input for lower and upper dimension boundaries and the number of boxes to be generated and,
using the injected generator, returns a list of boxes.

```
package hr.Base58;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import static hr.Base58.TestSCLP.*;

public class RandomBoxGenerator implements IBoxGenerator {

    IRandomGenerator randomGenerator;

    double maxWidth;
    double maxDepth;
    double maxHeight;
    double minWidth;
    double minDepth;
    double minHeight;
    int numberOfBoxes;

    public RandomBoxGenerator(IRandomGenerator randomGenerator){

        this.randomGenerator=randomGenerator;

    }


    public void inputUserBoxData(){

        Scanner dataScanner = new Scanner(System.in);

        System.out.println(ANSI_BLUE + "please enter the minimum dimensions of a randomly generated box"  + ANSI_RESET);

        System.out.println(ANSI_CYAN + "Please enter the minimum box width: " + ANSI_RESET);
        minWidth= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the minimum box depth: " + ANSI_RESET);
        minDepth= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the minimum box height: " + ANSI_RESET);
        minHeight= dataScanner.nextDouble();

        System.out.println(ANSI_BLUE + "please enter the maximum dimensions of a randomly generated box"  + ANSI_RESET);

        System.out.println(ANSI_CYAN + "Please enter the maximum box width: " + ANSI_RESET);
        maxWidth= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the maximum box depth: " + ANSI_RESET);
        maxDepth= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the maximum box height: " + ANSI_RESET);
        maxHeight= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the number of boxes to generate: " + ANSI_RESET);
        numberOfBoxes= dataScanner.nextInt();

    }

    @Override
    public List<Box> getBoxes() {

        inputUserBoxData();

        List<Box> boxes= new ArrayList<>(0);

        for(int i=0; i<numberOfBoxes; i++){

            boxes.add(new Box( "Box Type " + i,0,0, randomGenerator.nextDouble(minWidth, maxWidth),
                    randomGenerator.nextDouble(minDepth, maxDepth), randomGenerator.nextDouble(minHeight, maxHeight)) );

        }

        return boxes;

    }

    public static List<Box> getBoxesNonUserInput(IRandomGenerator randomGenerator, double maxWidth, double maxDepth, double maxHeight,
                                          double minWidth, double minDepth, double minHeight, int numberOfBoxes) {

        List<Box> boxes= new ArrayList<>(0);

        for(int i=0; i<numberOfBoxes; i++){

            boxes.add(new Box( "Box Type " + i,0,0, randomGenerator.nextDouble(minWidth, maxWidth),
                    randomGenerator.nextDouble(minDepth, maxDepth), randomGenerator.nextDouble(minHeight, maxHeight)) );

        }

        return boxes;

    }
}

```

## The RandomDoubleGenerator class
This class implements the IRandomGenerator interface and defines a method for generating a random double number with lower and upper boundaries. It uses the 
Singleton design pattern to prevent creating more than one object of the class with the same seed for random generation.

```
package hr.Base58;

import java.util.Random;

//Singleton random double number generator to prevent multiple instance creation with the same feed
public class RandomDoubleGenerator implements IRandomGenerator {

    private static RandomDoubleGenerator instance;
    private final Random randomGenerator;

    private RandomDoubleGenerator() {

        randomGenerator = new Random();

    }

    public static RandomDoubleGenerator getInstance() {

        if(instance == null) {
            instance = new RandomDoubleGenerator();
        }

        return instance;
    }

    public double nextDouble(double lowerBound, double upperBound) {

        return (randomGenerator.nextDouble() * (upperBound-lowerBound)) + lowerBound;

    }
}

```

## The SameSizedBoxGenerator class
The SameSizedBoxGenerator class is used to get a certain number of same-sized boxes using the getBoxes() method
with their dimensions defined by the user via the inputUserBoxData() method.

```
package hr.Base58;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import static hr.Base58.TestSCLP.*;

public class SameSizedBoxGenerator implements IBoxGenerator{

    double width;
    double depth;
    double height;
    int numberOfBoxes;

    public void inputUserBoxData(){
        Scanner dataScanner = new Scanner(System.in);

        System.out.println(ANSI_BLUE + "please enter the dimensions of boxes to be generated"  + ANSI_RESET);

        System.out.println(ANSI_CYAN + "Please enter the box width: " + ANSI_RESET);
        width= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the box depth: " + ANSI_RESET);
        depth= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the box height: " + ANSI_RESET);
        height= dataScanner.nextDouble();

        System.out.println(ANSI_CYAN + "Please enter the number of boxes to generate: " + ANSI_RESET);
        numberOfBoxes= dataScanner.nextInt();

    }
    @Override
    public List<Box> getBoxes() {

        inputUserBoxData();

        List<Box> boxes = new ArrayList<>(0);

        for (int i = 0; i < numberOfBoxes; i++) {

            boxes.add(new Box("Box type 0" , 0, 0, width, depth, height));

        }

        return boxes;

    }

}

```

## The UserInputBoxGenerator class
This class is a simple class which defines the methods to enable a user to input all the box sizes of the boxes to be generated.

```
package hr.Base58;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import static hr.Base58.TestSCLP.*;

public class UserInputBoxGenerator implements IBoxGenerator{

    @Override
    public List<Box> getBoxes() {

        List<Box> boxes = new ArrayList<>(0);


        Scanner dataScanner = new Scanner(System.in);


        System.out.println(ANSI_CYAN + "Please enter the number of box types: " + ANSI_RESET);

        int numOfBoxTypes=dataScanner.nextInt();

        double boxWidth, boxDepth, boxHeight;

        int sameBoxTypes;


        for(int i = 0; i<numOfBoxTypes; i++){

            System.out.println(ANSI_BLUE + "please enter the dimensions of the box type " + i + ANSI_RESET);

            System.out.println(ANSI_CYAN + "Please enter the box width: " + ANSI_RESET);
            boxWidth= dataScanner.nextDouble();

            System.out.println(ANSI_CYAN + "Please enter the box depth: " + ANSI_RESET);
            boxDepth= dataScanner.nextDouble();

            System.out.println(ANSI_CYAN + "Please enter the box height: " + ANSI_RESET);
            boxHeight= dataScanner.nextDouble();

            System.out.println("How many boxes with these dimensions do you have? ");

            sameBoxTypes = dataScanner.nextInt();

            for(int j = 0; j< sameBoxTypes; j++){

                boxes.add(new Box("Box type " + i,0,0 ,boxWidth, boxDepth, boxHeight ));

            }

        }
        return  boxes;
    }
}

```

## The WidthComparator class 
This class is used to override the compare() method of the built-in Comparer class. This new compare method returns true if the lhs depth is larger than the rhs depth.

```
package hr.Base58;

import java.util.Comparator;


public class WidthComparator implements Comparator<Box> {
    @Override
    public int compare(Box lhs, Box rhs) {

        return (Double.compare(lhs.getWidth(), rhs.getWidth()));

    }
}

```

## TestSCLP class
This is the main class used for testing the algorithm.
In the main method, the user is prompted to enter the container dimensions and the id of one of the above-mentioned box generators.
Depending on the user's choices, the program will test the algorithm with the chosen generation method and print out the box and box placement details.
The printed user prompts and results are color coded using ANSI escape codes. This class also defines some static methods for testing basic cases with no need for user input.
```
package hr.Base58;

import java.util.*;

public class TestSCLP {

    //ANSI Escape codes for color coding the console output (if supported)
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_CYAN = "\u001B[36m";
    public static final String ANSI_BLUE = "\u001B[34m";

    public static void runBasicDifferentSizedBoxTest(){
        Container container = new Container(1000,1000,300);

        List<Box> boxes = new ArrayList<>(0);
        for (int i = 0; i < 10; i++) {
            boxes.add(new Box("Box type 0", 0,0,300, 400, 111));
        }

        for (int i = 0; i < 12; i++) {
            boxes.add(new Box("Box type 0", 0,0,100, 100, 200));
        }
        for (int i = 0; i < 10; i++) {
            boxes.add(new Box("Box type 0", 0,0,100, 100, 100));
        }


        BoxLayerStacker boxLayerStacker= new BoxLayerStacker(boxes);

        List<List<Box>> layers =boxLayerStacker.stackLayers(container);

        int layerIndex = 0;

        for (List<Box> layer: layers) {

            System.out.println(ANSI_GREEN + "-----------------------------layer "+ ++layerIndex + "-----------------------------\n" + ANSI_RESET);

            for (Box box: layer) {

                System.out.println(box.toString()+ box.getPlacementCoordinateDetails() + "\n");

            }

        }

        System.out.println(ANSI_GREEN + "Box fitting complete, the total amount of placed boxes is: " + boxLayerStacker.getNumberOfPlacedBoxes() + ANSI_RESET);

        System.out.println();
    }

    public static void runBasicSameSizedBoxTest(){

        Container container = new Container(600,600,100);
        List<Box> boxes = new ArrayList<>(0);
        for (int i = 0; i < 37; i++) {
            boxes.add(new Box("Box type 0", 0,0,100, 100, 100));
        }
        // the algorithm should fit 36 boxes


        BoxLayerStacker boxLayerStacker= new BoxLayerStacker(boxes);

        List<List<Box>> layers =boxLayerStacker.stackLayers(container);

        int layerIndex = 0;

        for (List<Box> layer: layers) {

            System.out.println(ANSI_GREEN + "-----------------------------layer "+ ++layerIndex + "-----------------------------\n" + ANSI_RESET);

            for (Box box: layer) {

                System.out.println(box.toString()+ box.getPlacementCoordinateDetails() + "\n");

            }

        }

        System.out.println(ANSI_GREEN + "Box fitting complete, the total amount of placed boxes is: " + boxLayerStacker.getNumberOfPlacedBoxes() + ANSI_RESET);

        System.out.println();
    }

    public static void runBasicRandomGeneratedBoxesTest(){

        Container container = new Container(500,500,700);

        List<Box> boxes = RandomBoxGenerator.getBoxesNonUserInput(RandomDoubleGenerator.getInstance(),300, 300, 300,
                250,250,250,47);

        BoxLayerStacker boxLayerStacker= new BoxLayerStacker(boxes);

        List<List<Box>> layers =boxLayerStacker.stackLayers(container);

        int layerIndex = 0;

        for (List<Box> layer: layers) {

            System.out.println(ANSI_GREEN + "-----------------------------layer "+ ++layerIndex + "-----------------------------\n" + ANSI_RESET);

            for (Box box: layer) {

                System.out.println(box.toString()+ box.getPlacementCoordinateDetails() + "\n");

            }

        }

        System.out.println(ANSI_GREEN + "Box fitting complete, the total amount of placed boxes is: " + boxLayerStacker.getNumberOfPlacedBoxes() + ANSI_RESET);

        System.out.println();



    }

    public static void main(String[] args) {
        //Uncomment these lines to test the algorithm on some basic cases
        //runBasicSameSizedBoxTest();
        //runBasicDifferentSizedBoxTest();
        //runBasicRandomGeneratedBoxesTest();

        Scanner dataScanner = new Scanner(System.in);

        System.out.println( ANSI_BLUE + "Please enter the container dimensions " + ANSI_RESET);

        System.out.println(ANSI_CYAN + "Please enter the container width: " + ANSI_RESET);
        double containerWidth = dataScanner.nextDouble();

        System.out.println( ANSI_CYAN + "Please enter the container depth: " + ANSI_RESET);
        double containerDepth = dataScanner.nextDouble();

        System.out.println( ANSI_CYAN +"Please enter the container height: " + ANSI_RESET);
        double containerHeight = dataScanner.nextDouble();

        if(containerDepth<=0 || containerHeight<=0 || containerWidth<=0){
            System.out.println("Non-positive container dimensions values inputted. Closing Program.");
            return;
        }

        Container container = new Container(containerWidth, containerDepth, containerHeight);



        System.out.println( ANSI_BLUE +"Please enter the type of box generation.\n0 => random box generation\n1 =>" +
                                       " box generation from user input\n" +
                                       "2 => generate certain number of same-sized boxes" + ANSI_RESET);


        int boxGenerationIndex;

        do{
            boxGenerationIndex= dataScanner.nextInt();

            if(!(boxGenerationIndex>=0 && boxGenerationIndex<=2)){

                System.out.println("Please enter a valid box generation type (0 - 2) ");

            }
        }
        while(!(boxGenerationIndex >= 0 && boxGenerationIndex <= 2));

        IBoxGenerator boxGenerator;

        if(boxGenerationIndex == 0){

            boxGenerator = new RandomBoxGenerator(RandomDoubleGenerator.getInstance());

        }
        else if(boxGenerationIndex == 1){

            boxGenerator = new UserInputBoxGenerator();

        }
        else{

            boxGenerator= new SameSizedBoxGenerator();

        }

        List<Box> boxes= boxGenerator.getBoxes();

        for (Box box: boxes) {
            if(box.getWidth()<=0 || box.getHeight()<=0 || box.getDepth()<=0){
                System.out.println("Non-positive box dimensions values inputted. Closing Program.");
                return;
            }
        }




        BoxLayerStacker boxLayerStacker= new BoxLayerStacker(boxes);

        List<List<Box>> layers =boxLayerStacker.stackLayers(container);

        int layerIndex = 0;

        for (List<Box> layer: layers) {

            System.out.println(ANSI_GREEN + "-----------------------------layer "+ ++layerIndex + "-----------------------------\n" + ANSI_RESET);

            for (Box box: layer) {

                System.out.println(box.toString()+ box.getPlacementCoordinateDetails() + "\n");

            }

        }

        System.out.println(ANSI_GREEN + "Box fitting complete, the total amount of placed boxes is: " + boxLayerStacker.getNumberOfPlacedBoxes() + ANSI_RESET);

        System.out.println();
    }

}
```
## The Container class
This class is just a utility class which holds the dimensions of the container in which the boxes have to fit.
It is only used to make the code more understandable. Since the algorithm interprets both the containers and boxes as boxes, there is no need for this class to exist apart from
good looks.

```
package hr.Base58;

public class Container {

    private final double width;
    private final double height;
    private final double depth;

    public Container(double width, double depth,  double height) {

        this.width = width;
        this.height = height;
        this.depth = depth;

    }


    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getDepth() {
        return depth;
    }

}

```





